# 영속성 관리



#### 서론 

JPA 가 제공하는 기능은 **엔티티와 테이블을 매핑하는 설계** 와, **매핑한 엔티티를 실제로 사용하는 부분**으로 나눌 수 있다.

이러한 엔티티들은 **엔티티 매니저** 를 통해 관리(사용) 할 수 있다.





#### 엔티티 매니저 팩토리와 엔티티 매니저



##### 엔티티매니저 팩토리란 ?

엔티티 매니저 팩토리는 말 그대로 엔티티 매니저를 만드는 공장이다.

엔티티 매니저 팩토리는 생성 비용이 매우 크기 때문에 애플리케이션 당 하나만 만들어, 애플리케이션 전체에서 공유해야한다.

엔티티 매니저 팩토리가 생성될때 커넥션 풀도 생성한다.



##### 엔티티매니저 란?

엔티티 매니저는 엔티티를 저장, 수정, 삭제, 조회 등 엔티티와 관련된 모든 일을 수행한다.

이름 그대로 엔티티를 관리하는 관리자 역할을 한다.

엔티티 매니저는 데이터베이스 연결이 꼭 필요한 시점까지 커넥션을 얻지 않으며, 일반적으로 **트랜잭션을 시작할 때 커넥션을 획득**한다.



> 엔티티 매니저 팩토리는 스레드 세이프하지만, 엔티티 매니저는 스레드 세이프하지 않아 스레드간 공유해서는 안된다.





#### 영속성 컨텍스트란 ?



영속성 컨텍스트 (Persistence Context) 는 **엔티티를 영구 저장하는 환경** 이다.

엔티티 매니저를 통해 엔티티를 관리하면 **영속성 컨텍스트를 통해 관리**하게 된다.



#### 엔티티의 생명 주기



1. 비영속(new/transient): 영속성 컨텍스트와는 상관이 없는 상태
2. 영속(managed): 영속성 컨텍스트가 관리하는 상태
3. 준영속(detached): 영속성 컨텍스트가 관리중이었다가 관리를 하지 않는 상태
4. 삭제(removed): 삭제된 상태



##### 비영속



비영속 상태는 엔티티 객체를 생성했으나, 영속성 컨텍스트나 데이트베이스와는 관련이 없는 상태 이다.

쉽게 생각하면 **new 키워드를 통해 새롭게 생성한 객체** 이다.



```java
Member member = new Member("member1", "회원1");
```



##### 영속



영속 상태는 **엔티티 매니저를 통해 영속성 컨텍스트가 관리하는 상태** 이다.



````java
Member member = new Member("member1", "회원1");
em.persist(member); // 영속화
````



 

##### 준영속



영속성 컨텍스트가 관리하던 **영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않는 상태**이다.



````java
Member member = new Member("member1", "회원1");
em.persist(member); // 영속화
em.detach(member); // 준영속화
````





##### 삭제



엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제



````java
Member member = new Member("member1", "회원1");
em.persist(member); // 영속화
em.detach(member); // 준영속화
em.remove(member); // 삭제
````





#### 영속성 컨텍스트의 특징



1. 영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다. 따라서 **영속 상태의 엔티티는 식별자 값이 반드시 있어야 한다.**
2. JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 **새로운 데이터베이스에 반영하는데 이것을 플러시(flush) 라고 한다.**
3. 영속성 컨텍스트를 사용할때의 장점
   1. 1차캐시
   2. 동일성 보장
   3. 트랜잭션을 지원하는 쓰기 지연
   4. 변경 감지
   5. 지연 로딩





##### 1차 캐시



영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 **1차 캐시**라고 한다.

영속상태의 엔티티는 모두 이곳에 저장된다.



````java
Member member = new Member("member1", "회원1");
em.persist(member) // 영속화
````



##### 1차 캐시에서 조회



영속성 컨텍스트에서 엔티티를 조회하게 되면 먼저 1차 캐시에서 식별자값을 통해 엔티티를 조회한다.

영속성 컨텍스트에 엔티티가 없다면, 데이터베이스에서 새롭게 조회한뒤 영속성 컨텍스트에 저장을 하고,

저장된 영속성 컨텍스트를 반환한다.



```java
Member member = new Member("member1", "회원1");
em.persist(member) // 영속화
  
Member findMember = em.find(Member.class, "member1"); // 1차캐시에서 조회
```





##### 엔티티의 동일성 보장



````java
Member member = new Member("member1", "회원1");
em.persist(member) // 영속화
  
Member findMember1 = em.find(Member.class, "member1"); // 1차캐시에서 조회
Member findMember2 = em.find(Member.class, "member1"); // 1차캐시에서 조회

findMember1 == findMember2; // true
````



> 한 트랜잭션 내에서 영속성 컨텍스트는 동일 식별자에 대한 엔티티에 대해 동일성을 보장한다.
>
> 같은 트랜잭션 내에서는 수차례 조회해도 1차 캐시에 존재하는 같은 엔티티 인스턴스를 반환한다.





##### 쓰기 지연



엔티티 매니저는 트랜잭션을 커밋하기 직전까지 내부 쿼리 저장소에 SQL을 모아뒀다가 트랜잭션을 Commit 하는 시점에 모아둔 쿼리를 한번에 데이터베이스에 보내게 된다.

이것을 트랜잭션을 지원하는 쓰기 지연 (write-behind) 라고 한다.





##### 변경 감지



기존에 SQL을 사용하는 방식은 수정 쿼리를 직접 작성해야 한다.

엔티티가 수정되거나, 비즈니스가 변경되면 SQL도 동일하게 변경되어야 한다.

SQL을 변경하는 과정에서 오탈자 (휴먼에러)가 발생할 수 있고, 여러개의 수정쿼리가 발생할 수 있다.



JPA로 엔티티를 수정할 때는 엔티티를 조회해서, 데이터만 변경하면 된다.

트랜잭션 커밋 직전에 스냅샷과 엔티티를 변경된 엔티티를 찾아, 엔티티의 변경점을 데이터베이스에 자동으로 반영을 해준다.

이러한 기능을 **변경 감지(dirty checking)** 이라고 한다.



```java
Member findMember = em.find(Member.class, "member1");
findMember.setName("changeMemberName");
```



> 변경 감지 기능은 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.
>
> 영속성 컨텍스트가 관리하지 않는 엔티티는 값이 변경되어도 데이터베이스에 반영되지 않는다.



`JPA의 데이터 수정 기본 전략`

- 기본 전략은 엔티티의 모든 필드를 수정한다.
- 데이터 전송량이 증가하지만, 쿼리를 재사용할수 있기 때문에 성능상 이점을 가져온다.
- 일반적으로 컬럼이 30개가 넘어가지 않는 이상 모든 컬럼을 수정하는 쿼리를 재사용하는것이 성능상 이득이다.





#### 플러시



플러시(flush) 는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.



##### 영속성 컨텍스트를 Flush 하는 방법

1. em.flush()

2. 트랜잭션 커밋시 자동 호출

   - 변경 내용을 SQL로 전달하지 않고 트랜잭션만 커밋하면 어떤 데이터도 데이터베이스에 반영되지 않는다. 

3. JPQL 쿼리 실행시 자동 호출

   - JPQL쿼리 실행 이전에 엔티티 매니저를 통해 엔티티를 영속화 했다면, 데이터베이스에는 해당 엔티티에 대한 정보가 없는 상태이다.

   - JPQL은 SQL로 변환되어 데이터베이스에서 엔티티를 조회하기 때문에 영속화된 엔티티를 조회할수 없다.





#### 준 영속



영속성 컨텍스트가 관리하던 영속상태의 엔티티가 영속성 컨텍스트에 분리된 것을 **준영속(detach)** 상태 라고 한다.



`영속상태의 엔티티를 준 영속상태로 만드는 방법`

1. em.detach(entity); 
   - 특정 엔티티를 준영속화 한다.
2. em.clear();
   - 영속성 컨텍스트를 완전히 초기화한다.
3. em.close();
   - 영속성 컨텍스트를 종료한다.



##### 준영속 상태의 특징

1. 비영속 상태에 가깝다.
   - 영속성 컨텍스트가 관리하지 않으므로, 1차 캐시, 쓰기지연 등 영속성 컨텍스트가 제공하는 기능이 동작하지 않는다.
2. 식별자 값을 가지고 있다.
   - 이미 한번 영속화 되었기 때문에 반드시 식별자를 가지고 있다.
3. 지연 로딩을 할 수 없다.
   - 영속성 컨텍스트가 관리하지 않으므로 지연로딩시 문제가 발생한다.





#### Merge가 머지 ?



준영속 상태의 엔티티를 다시 영속 상태로 변경하려면 Merge를 사용하면 된다.

merge() 메소드는 준영속 상태의 엔티티를 받아, 해당 정보로 새로운 영속상태의 엔티티를 반환한다.



병합은 준영속, 비영속상태를 신경쓰지 않는다. 식별자로 엔티티를 조회할수 있다면 병합을 하고, 없다면 새롭게 생성을 하여 병합을 시도한다. **save or update**



> merge()를 호출하면 파라메터로 들어온 엔티티와, 반환된 엔티티가 동일하지 않다.





#### 정리



- 엔티티 매니저는 엔티티 매니저 팩토리에서 생성한다.
- 엔티티 매니저 팩토리는 애플리케이션 당 하나만 생성해야하고, 엔티티 매니저는  스레드간에 공유해서는 안된다.
- 엔티티 매니저를 사용하면 영속성 컨텍스트를 통해 엔티티를 관리하게 되는데 **1차캐시, 동일성 보장, 쓰기지연, 변경감지, 지연 로딩** 기능을 사용할 수 있다.
- 영속성 컨텍스트에 저장한 엔티티는 Flush해야 데이터베이스에 저장된다.
