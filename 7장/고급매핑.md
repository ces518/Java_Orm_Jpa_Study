# 7장 고급 매핑





### 상속관계 매핑



관계형 데이터베이스에는 객체지향 언어에서 다루는 상속이라는 개념이 없다.

그나마 유사한 형태의 모델은 **슈퍼타입 서브타입 관계** 모델이다.



##### 슈퍼타입 서브타입을 매핑하는 방법

- 각각의 테이블로 변환
  - 슈퍼타입에 해당하는 테이블을 만들고, 각각의 서브타입에 해당하는 테이블을 만들어 **조인 을 사용하여 해결한다.** JPA에서는 조인전략이라고 한다.
- 통합 테이블로 변환
  - 하나의 테이블에 DTYPE (타입 플래그) 값을 이용해 테이블을 하나만 사용해서 해결한다. JPA에서는 단일 테이블 전략이라고 한다.
- 서브타입 테이블로 변환
  - 서브 타입마다 하나의 테이블을 만들어 해결한다. JPA에서는 구현 클래스마다 테이블 전략이라 한다.



#### 조인 전략



조인 전략은 엔티티 각각을 모두 테이블로 만들고, **자식 테이블이 부모 테이블의 기본키를 받아 기본키 + 외래 키로 사용하는 전략**이다.



````java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {
  
	@Id @GeneratedValue
  @Column(name = "ITEM_ID")
  private Long id;
  
  private String name;
  private int price;
  ...
}

@Entity
@DiscriminatorValue("A")
public class Album extends Item {
  private String artist;
  ...
}

@Entity
@DiscriminatorValue("M")
public class Movie extends Item {
  private String director;
  private String actor;
  ...
}
````





- @Inheritance(strategy = InheritanceType.JOINED)
  - 상속 매핑은 부모클래스에 @Inheritance 애노테이션을 사용해야한다.
  - 매핑전략을 JOIN 전략으로 지정한다.
- @DiscriminatorColumn(name = "DTYPE")
  - 부모 클래스에 구분 컬럼을 지정한다.
  - 기본값은 DTYPE 이다.
- @DiscriminatorValue("A")
  - 엔티티를 저장할때 구분 컬럼에 입력할 값을 지정한다.
  - 기본값은 엔티티의 이름이다.



> 이 전략을 사용하면, 자식 테이블은 부모 테이블의 ID 컬럼명을 그대로 사용하는데, 만약 자식 테이블의 기본 키 컬럼명을 변경하고 싶다면 **@PrimaryKeyJoinColumn(name = "사용할 컬럼명")** 애노테이션을 사용하면 된다.





- 정규화된 테이블을 사용하기 때문에 저장공간을 효율적으로 사용한다.
- 조회 쿼리가 복잡해지고, 조인을 사용하기 때문에 성능이 저하될 수 있다.
- 커맨드성 SQL이 두번 발생한다.





#### 단일 테이블 전략



단일 테이블 전략은 이름 그대로 하나의 테이블만을 사용하여 이를 해결한다.

**구분 컬럼 (DTYPE) 을 사용하여 어떤 자식데이터인지 구분**한다.



> 이 전략을 사용할때의 주의점은 자식 엔티티가 매핑한 컬럼은 모두 Nullable 이어야 한다.



````java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {
  
  @Id @GeneratedValue
  @Column(name = "ITEM_ID")
  private Long id;
  private String name;
  private int price;
}

@Entity
@DiscriminatorValue("A")
public class Album extends Item {
  ...
}

@Entity
@DiscriminatorValue("M")
public class Movie extends Item {
  ...
}
````



> InheritanceType.SINGLE_TABLE 을 사용하면 단일 테이블 전략을 사용한다.
>
> 테이블 하나에 모든 데이터를 저장하기 때문에 구분 컬럼을 필수로 사용해야한다.



- 조회 쿼리가 단순하다.
- 자식 엔티티가 매핑한 컬럼은 모두 Nullable 이어야 한다.
- 단일 테이블에 모든 데이터를 저장하므로 테이블의 크기가 커질수 있으며, 조회 성능이 오히려 저하될 수도 있다.





#### 구현 클래스마다 테이블 전략



구현 클래스마다 테이블 전략은 자식 엔티티마다 별도의 테이블을 생성한다.

따라서 자식 테이블에 각각 필요한 컬럼이 모두 존재한다.



````java
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {
  
  @Id @GeneratedValue
  @Column(name = "ITEM_ID")
  private Long id;
  private String name;
  private int price;
}

@Entity
@DiscriminatorValue("A")
public class Album extends Item {
  ...
}

@Entity
@DiscriminatorValue("M")
public class Movie extends Item {
  ...
}
````



> InheritanceType.TABLE_PER_CLASS를 사용하면 구현 클래스 마다 테이블 전략을 사용한다.
>
> 이 전략은 자식 엔티티마다 테이블을 만드는 전략이다.
>
> 일반적으로 추천하지 않는 전략이며, 조인이나 단일 테이블 전략을 추천한다.



- 서브 타입을  구분해서 처리할 때 효과적이다.
- 여러 자식테이블을 함께 조회할때 UNION을 사용해야 한다.





#### @MappedSuperclass



**부모 클래스를 상속 받는 자식클래스에게 매핑 정보만 제공하고 싶을때** 사용하는 애노테이션이다.



> @Entity 는 실제 테이블과 매핑되지만, @MappedSuperclass는 실제 테이블과 매핑되지 않고 단순히 매핑정보를 상속할 목적으로만 사용된다.





````java
@MappedSuperclass
public abstract class BaseEntity {
  @Id @GeneratedValue
  private Long id;
  private String name;
}

@Entity
public class Member extends BaseEntity {
  private String email;
  ...
}
````





> BaseEntity 에는 객체들이 주로 사용하는 공통 매핑정보를 정의한뒤, 자식 엔티티들이 상속하여 매핑정보를 물려받는 구조이다.





##### 매핑정보 재정의하기



부모로 부터 상속받은 매핑정보를 재정의 하려면 다음과 같은 애노테이션을 사용하여 재정의 할 수 있다.

- @AttirbuteOverride(s)
  - 부모로 부터 물려받은 매핑 정보를 재정의 할때 사용한다.
- @AssociationOverride(s)
  - 부모로 부터 물려받은 연관관계를 재정의 할때 사용한다.



````java
@MappedSuperclass
public abstract class BaseEntity {
  @Id @GeneratedValue
  private Long id;
  private String name;
}

@Entity
@AttirbuteOverride(name = "id", column = @Column(name = "MEMBER_ID"))
public class Member extends BaseEntity {
  private String email;
  ...
}
````





### 복합 키와 식별 관계 매핑





#### 식별 관계와 비식별 관계



데이터베이스 테이블 사이의 관계는 외래 키가 기본 키에 포함되는지 여부에 따라 식별 관계와 비식별 관계로 구분된다.



##### 식별 관계

- 식별 관계는 부모 테이블의 기본 키를 내려 받아 자식 테이블의 기본키 + 외래 키로 사용하는 관계이다.



##### 비식별 관계

- 비식별 관계는 부모 테이블의 기본 키를 받아서 자식 테이블의 외래 키로만 사용하는 관계이다.
- 필수적 비식별 관계(Mandatory)
  - 외래키에 NULL을 허용하지 않는다.
- 선택적 비식별 관계(Optional)
  - 외래 키가 Nullable 하다.





#### 복합키: 비식별 관계 매핑



JPA는 복합 키를 지원하기 위해 @IdClass와 @EmbeddedId 2가지 방법을 제공한다.

@IdClass는 관계형 데이터베이스에 가까운 방법이고, @EmbeddedId는 좀 더 객체지향에 가까운 방법이다.





##### @IdClass



````java
@Entity
@IdClass(ParentId.class)
public class Parent {
  @Id
  @Column(name = "PARENT_ID1")
  private String id1;
  
  @Id
  @Column(name = "PARENT_ID2")
  private String id2;
}

public class ParentId implements Serializable {
  private String id1;
  private String id2;
  
  equals()
  hashCode()
  ...
}
````





- @IdClass를 사용할 때 식별자 클래스의 속성명과 엔티티에서 사용하는 식별자의 속성명이 같아야한다.
- Serializable 인터페이스를 구현해야 한다.
- Equals, hashCode 를 구현해야한다.
- 기본 생성자가 있어야 한다.
- 식별자 클래스는 public 이어야 한다.



> @IdClass 를 사용하면, 식별자 클래스인 ParentId를 직접 사용하지 않는다.
>
> em.persist() 를 호출할때 영속성 컨텍스트 내부에서 식별자 클래스인 ParentId를 생성하여, 영속성 컨텍스트의 키로 사용한다.
>
> 조회시에는 식별자 클래스인 ParentId를 사용해서 엔티티를 조회한다.





##### 자식 엔티티와의 매핑

````java
@Entity
public class Child {
  @Id
  private String id;
  
  @ManyToOne
  @JoinColumns({
    	@JoinColumn(name = "PARENT_ID1", referencedColumnName = "PARENT_ID1"),
    	@JoinColumn(name = "PARENT_ID2", referencedColumnName = "PARENT_ID2")
  })
  private Parent parent;
}
````



> @JoinColum 의 name 속성과 referencedColumnName 속성의 값이 같다면 referencedColumnName 속성은 생략이 가능하다.





##### @EmbbedId



@IdClass가 데이터베이스에 맞춘 방법이라면 @EmbeddedId 는 좀 더 객체지향적인 방법이다.



````java
@Entity
public class Parent {
  @EmbeddedId
  private ParentId id;
  
  private String name;
  
  ...
}

@EmbeddedId
public class ParentId implements Serializable {
  
  @Column(name = "PARENT_ID1")
  private String id1;
  
  @Column(name = "PARENT_ID2")
  private String id2;
  
}
````



> @IdClass 와는 다르게 @EmbeddedId를 적용한 식별자 클래스는 식별자 클래스에 기본 키를 직접 매핑한다.



- @Embeddable 애노테이션을 사용해야한다.
- Serializable 인터페이스를 구현해야 한다.
- Equals, hashCode를 구현해야 한다.
- 기본 생성자가 있어야 한다.
- 식별자 클래스는 public 이어야 한다.



> 엔티티를 저장할때 @IdClass와 달리 식별자 클래스를 직접 생성해서 사용한다.
>
> 조회 코드에서도 마찬가지이다.



##### 복합키와 equals(), hashCode()



복합키는 equals()와 hashCode()를 필수로 구현해야 한다. 

식별자 클래스도 결국 순수 자바 클래스이다. 자바의 모든 클래스는 기본적으로 Object 클래스를 상속 받는다.

equals() 는 기본적으로 참조값 비교인 == 비교 (동일성 비교)를 하기 때문에 필수적으로 재정의 해주어야 한다.



영속성 컨텍스트는 엔티티의 식별자를 키로 사용해서 엔티티를 관리한다.

식별자 비교시 equals(), hashCode() 를 사용한다. 식별자 객체의 동등성이 지켜지지 않으면, 전혀 다른 엔티티가 조회되거나 엔티티를 찾을 수 없는등 문제가 발생한다.



##### @IdClass 와 @EmbeddedId



@IdClass와 @EmbeddedId는 각각 장단점이 있어 본인의 취향에 맞게 사용하면된다.

하지만 상황에 따라 JPQL이 더 길어질수 있으므로 유의해야 한다.
